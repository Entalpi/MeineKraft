#include "filesystem.hpp"

#include "logging.hpp"
#include "../math/vector.hpp"

/// Tries to save the pixels as RGB PPM format
std::string Filesystem::save_image_as_ppm(const std::string filename, const float* pixels, const size_t w, const size_t h, const float downsample_factor = 1.0f, const TextureFormat fmt = TextureFormat::RGB32F) {
  assert(downsample_factor >= 1.0f && "Downsample factor must be larger or equal to 1.0");

  std::filesystem::path filepath = filename;

  const auto time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
  std::string timestamp = std::ctime(&time);
  timestamp.erase(std::remove(timestamp.begin(), timestamp.end(), '\n'), timestamp.end()); // Trim \n
  filepath += "-" + std::regex_replace(timestamp, std::regex(" "), "-"); // Replace whitespace with '-'

  filepath += ".ppm";

  if (w == 0 || h == 0) {
    Log::warn("Tried save screenshot with width or height of zero.");
    return "";
  }

  if (!pixels) {
    Log::warn("Tried to save screenshot with no pixels.");
    return "";
  }

  if (filepath.empty()) {
    Log::warn("Tried to save screenshot with empty filepath.");
    return "";
  }

  if (std::filesystem::is_directory(filepath)) {
    Log::warn("Tried to save screenshot with a directoy filepath: " + filepath.string());
    return "";
  }

  const size_t width  = static_cast<size_t>(w / downsample_factor);
  const size_t height = static_cast<size_t>(h / downsample_factor);

  std::ofstream file(filepath);
  file << "P3 \n";                                                        // ASCII RGB magic number
  file << std::to_string(width) << " " << std::to_string(height) << "\n"; // Image dimension in pixels
  file << "255 \n";                                                       // Maximum color channel value
  file << "# Image generated by MeineKraft rendering engine \n";

  // NOTE: OpenGL origin is lower left so flip the image
  const int32_t starty = (h - 1) / downsample_factor;
  const int32_t stopy  = 0;
  const uint32_t startx = 0;
  const uint32_t stopx  = w / downsample_factor;
  assert(stopx > startx);
  for (int32_t y = starty; y >= stopy; y--) {
    for (uint32_t x = startx; x < stopx; x++) {
      switch (fmt) {
        case TextureFormat::RGB32F:
          {
            const float px = pixels[y * w + x + 0];
            const float py = pixels[y * w + x + 1];
            const float pz = pixels[y * w + x + 2];
            file << std::to_string(static_cast<uint8_t>(px * 255.0f)) + " ";
            file << std::to_string(static_cast<uint8_t>(py * 255.0f)) + " ";
            file << std::to_string(static_cast<uint8_t>(pz * 255.0f)) + " ";
          }
          break;
        case TextureFormat::R32F:
          {
            const float px = pixels[y * w + x + 0];
            file << std::to_string(static_cast<uint8_t>(px * 255.0f)) + " ";
            file << std::to_string(static_cast<uint8_t>(px * 255.0f)) + " ";
            file << std::to_string(static_cast<uint8_t>(px * 255.0f)) + " ";
          }
          break;
      }
    }
  }

  file.close();

  Log::info("Screenshot saved at: " + filepath.string());
  return filepath;
}

/// Returns filepath to the saved file if it was created successfully, otherwise empty string
std::string Filesystem::save_image_as(const std::string filename, const ImageFormat img_fmt, const float* pixels, const size_t w, const size_t h, const float downsample_factor = 1.0f, const TextureFormat texture_fmt = TextureFormat::RGB32F) {
  switch (img_fmt) {
    case ImageFormat::PPM:
      return Filesystem::save_image_as_ppm(filename, pixels, w, h, downsample_factor, texture_fmt);
    case ImageFormat::PNG:
      return Filesystem::save_image_as_png(filename, pixels, w, h, downsample_factor, texture_fmt);
  }
  Log::warn("Unsupported imageformat"); // FIXME: Which imageformat?
}
