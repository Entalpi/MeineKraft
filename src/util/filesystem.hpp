#pragma once
#ifndef MEINEKRAFT_FILESYSTEM_HPP
#define MEINEKRAFT_FILESYSTEM_HPP

#include <fstream>
#include <filesystem>
#include <algorithm>
#include <string>

#include "logging.hpp"
#include "../math/vector.hpp"

// TODO: Make the paths dynamic rather than static
namespace Filesystem {
  /// Base filepath to the executeable root folder
#if defined(__linux__)
  const std::string base = "/home/alexander/repos/MeineKraft-2/MeineKraft/";
#elif defined(_WIN32) || defined(_WIN64)
  const std::string base = "C:/Users/Alexander/repos/MeineKraft/";
#endif
  
#if defined(__linux__)
  const std::string home = "/home/alexander/";
#elif defined(_WIN32) || defined(_WIN64)
  const std::string home = "C:/Users/Alexander/";
#endif

  const std::string tmp = Filesystem::base + "tmp/";

  /// Check whether a file exists or not
  inline bool file_exists(const std::string& filename) {
    std::ifstream ifs(filename);
    return ifs.good();
  }

  /// Reads the entire contents of the file and returns it
  inline const std::string read_file(const std::string& filename) {
    std::ifstream ifs(filename); 
    return std::string((std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
  }

  /// Tries to create the directory if it is not already present
  inline void create_directory(const std::string& filepath) {
    std::filesystem::create_directory(filepath);
  }

  /// Tries to save the pixels as RGB PPM format
  /// Returns true if the file was created successfully
  inline bool save_image_as_ppm(const std::string filename, const Vec3f* pixels, const size_t w, const size_t h) {
    std::filesystem::path filepath = filename;

    const auto time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    std::string timestamp = std::ctime(&time);
    timestamp.erase(std::remove(timestamp.begin(), timestamp.end(), '\n'), timestamp.end()); // Trim \n
    filepath += "-" + timestamp;

    filepath += ".ppm";

    if (w == 0 || h == 0) {
      Log::warn("Tried save screenshot with width or height of zero.");
      return false;
    }

    if (!pixels) {
      Log::warn("Tried to save screenshot with no pixels.");
      return false;
    }

    if (filepath.empty()) {
      Log::warn("Tried to save screenshot with empty filepath.");
      return false;
    }

    if (std::filesystem::is_directory(filepath)) {
      Log::warn("Tried to save screenshot with a directoy filepath: " + filepath.string());
      return false;
    }

    std::ofstream file(filepath);
    file << "P3 \n";                                                  // ASCII RGB magic number
    file << std::to_string(w) << " " << std::to_string(h) << "\n";    // Image dimension in pixels
    file << "255 \n";                                                 // Maximum color channel value
    file << "# Image generated by MeineKraft rendering engine \n";

    // NOTE: OpenGL origin is lower left so flip the image
    for (int32_t y = h - 1; y >= 0; y--) {
      for (uint32_t x = 0; x < w; x++) {
        const Vec3f& p = pixels[y * w + x];
        file << std::to_string(static_cast<uint8_t>(p.x * 255.0f)) + " ";
        file << std::to_string(static_cast<uint8_t>(p.y * 255.0f)) + " ";
        file << std::to_string(static_cast<uint8_t>(p.z * 255.0f)) + " ";
      }
    }
   
    file.close();

    Log::info("Screenshot saved at: " + filepath.string());
    return true;
  }
}

#endif // MEINEKRAFT_FILESYSTEM_HPP
